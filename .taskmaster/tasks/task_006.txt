# Task ID: 6
# Title: Create Shared Utility Packages
# Status: pending
# Dependencies: 1
# Priority: medium
# Description: Implement shared utility packages for common functionality, types, and email services, and create a frontend showcase to demonstrate and test these utilities. Follow the prescribed folder structure to ensure consistency and discoverability.
# Details:
Create packages/lib with utility functions, validation helpers, formatting functions, and shared constants, organized as follows: utils/ (general utilities), validations/ (validation helpers), formatters/ (formatting functions), helpers/ (miscellaneous helpers), and types.ts (shared types). Implement packages/types with comprehensive TypeScript definitions for API, auth, billing, database, and UI types, organized into shared.ts, api.ts, and database.ts. Build packages/email with email templates and providers, structured as templates/ (email templates), providers/ (email service integrations), and utils/ (email-specific helpers). In addition, develop a frontend showcase app with the following structure: apps/web/app/utilities-demo/ (page.tsx, components/), apps/web/app/email-preview/ (template preview page). The showcase should include: /utilities-demo (interactive examples of all utility functions), /email-preview (live preview of all email templates), /type-definitions (display and document all TypeScript types and interfaces), interactive form validation demos using utility functions, a utilities testing playground for real-time function testing, and performance benchmarks for utility function speeds. The showcase should allow users to interact with and verify the behavior of all shared utilities.

# Test Strategy:
Unit test all utility functions, validate TypeScript type definitions compile correctly, test email template rendering, mock email provider APIs, and verify shared constants are accessible across packages. For the frontend showcase, perform end-to-end tests to ensure all demo pages load and function correctly, interactive examples reflect actual utility outputs, email previews render as expected, type documentation matches the source, form validation demos work with various inputs, the utilities playground provides real-time feedback, and performance benchmarks display accurate timing results.

# Subtasks:
## 1. Set up project structure for shared packages [pending]
### Dependencies: None
### Description: Create the foundational directory structure for packages/lib, packages/types, and packages/email with appropriate configuration files
### Details:
Initialize the packages directory with the following folder structure: packages/lib/ (utils/, validations/, formatters/, helpers/, types.ts), packages/types/ (shared.ts, api.ts, database.ts), packages/email/ (templates/, providers/, utils/). Create package.json files for each package with appropriate dependencies. Set up TypeScript configuration, build scripts, and export definitions. Configure package visibility and access for internal project consumption.

## 2. Implement utility functions in packages/lib [pending]
### Dependencies: 6.1
### Description: Develop core utility functions, validation helpers, formatting functions, and shared constants
### Details:
Create modular utility functions organized by category within packages/lib: utils/ for general utilities, validations/ for validation helpers, formatters/ for formatting functions, helpers/ for miscellaneous helpers, and types.ts for shared types. Ensure each function is placed in the appropriate folder according to its purpose.

## 3. Create TypeScript type definitions in packages/types [pending]
### Dependencies: 6.1
### Description: Develop comprehensive TypeScript definitions for API, auth, billing, database, and UI types
### Details:
Define interfaces and types for API request/response objects in api.ts, authentication and authorization related types in shared.ts, billing and payment processing type definitions in shared.ts, database entity and query result types in database.ts, and UI component prop and state types in shared.ts. Organize all type definitions according to the prescribed folder structure.

## 4. Build email templates in packages/email [pending]
### Dependencies: 6.1
### Description: Create standardized email templates for welcome messages, password resets, and invoices
### Details:
Design HTML and text versions of email templates in packages/email/templates/. Implement welcome email template with personalization options, password reset email with secure token handling, and invoice email template with formatting for line items and totals. Place any email-specific helpers in packages/email/utils/. Ensure templates are responsive and work across email clients.

## 5. Implement email service providers in packages/email [pending]
### Dependencies: 6.4
### Description: Develop integration with Resend and SendGrid email service providers
### Details:
Create provider-agnostic email sending interface in packages/email/providers/. Implement Resend provider with API integration and SendGrid provider with appropriate configuration. Add provider selection logic based on configuration. Implement retry and error handling for failed email delivery.

## 6. Develop utilities showcase frontend [pending]
### Dependencies: 6.2, 6.3, 6.4
### Description: Create a frontend demo app to showcase and test all shared utilities, types, and email templates
### Details:
Implement the frontend showcase in apps/web/app/ with the following structure: utilities-demo/ (page.tsx, components/) for interactive examples of every utility function, allowing users to input data and see results in real-time; email-preview/ (template preview page) for rendering all email templates with live preview and variable substitution. Create a /type-definitions page that lists all TypeScript types and interfaces with inline documentation. Add interactive form validation demos using the validation helpers from packages/lib. Develop a utilities testing playground for users to experiment with utility functions. Include performance benchmarks that display execution times for utility functions. Ensure the demo app is easy to navigate and visually demonstrates the capabilities of the shared packages.

